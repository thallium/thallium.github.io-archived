---
published: true
title: Tutorial for Atcoder Educational DP Contest M - Candies
category: 题解/Tutorial
tags:
- 动态规划/DP
layout: post
---

<!-- more -->

## Solution

Let $dp_{i,j}$ be the number of ways to distribute $j$ candies to the first $i$ kids. If we give $k$ candies to the $i$-th kid, we should add $dp_{i-1,j-k}$ to $dp_{i,j}$. Since $k$ takes all the values from $0$ to $a_i$, so $dp_{i,j}=\sum_{k=0}^{a_i}dp_{i-1,j-k}$. Note that we take a segment of $dp_{i-1}$, so we can use prefix sum.

There's one optimization: the first dimension of $dp$ is useless, we only need to store the latest $dp$ array.

## Code
```cpp
#include <bits/stdc++.h>

#define forn(i, n) for (int i = 0; i < int(n); ++i)
#define for1(i, n) for (int i = 1; i <= int(n); ++i)
#define F first
#define S second
#define all(x) (x).begin(),(x).end()
#define sz(x) int(x.size())
#define pb push_back

using namespace std;
using ll=long long;
using pii= pair<int, int>;
mt19937 gen(chrono::steady_clock::now().time_since_epoch().count());
template<typename... T> void rd(T&... args) {((cin>>args), ...);}
template<typename... T> void wr(T... args) {((cout<<args<<" "), ...);cout<<endl;}


const int mod=1e9+7;
template <int MOD>
struct ModInt {
    int val;
    // constructor
    ModInt(ll v = 0) : val(int(v % MOD)) {
        if (val < 0) val += MOD;
    };
    // unary operator
    ModInt operator+() const { return ModInt(val); }
    ModInt operator-() const { return ModInt(MOD - val); }
    ModInt inv() const { return this->pow(MOD - 2); }
    // arithmetic
    ModInt operator+(const ModInt& x) const { return ModInt(*this) += x; }
    ModInt operator-(const ModInt& x) const { return ModInt(*this) -= x; }
    ModInt operator*(const ModInt& x) const { return ModInt(*this) *= x; }
    ModInt operator/(const ModInt& x) const { return ModInt(*this) /= x; }
    ModInt pow(ll n) const {
        auto x = ModInt(1);
        auto b = *this;
        while (n > 0) {
            if (n & 1) x *= b;
            n >>= 1;
            b *= b;
        }
        return x;
    }
    // compound assignment
    ModInt& operator+=(const ModInt& x) {
        if ((val += x.val) >= MOD) val -= MOD;
        return *this;
    }
    ModInt& operator-=(const ModInt& x) {
        if ((val -= x.val) < 0) val += MOD;
        return *this;
    }
    ModInt& operator*=(const ModInt& x) {
        val = int(ll(val) * x.val % MOD);
        return *this;
    }
    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }
    // compare
    bool operator==(const ModInt& b) const { return val == b.val; }
    bool operator!=(const ModInt& b) const { return val != b.val; }
    // I/O
    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }
    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }
};
using mint=ModInt<mod>;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,k;
    cin>>n>>k;
    vector<int> a(n);
    for(auto& it:a) cin>>it;
    vector<mint> dp(k+1);
    dp[0]=1;
    for(int i=0;i<n;i++){
        vector<mint> sum(k+2),ndp(k+1);
        partial_sum(all(dp),sum.begin()+1);
        for(int j=0;j<=k;j++){
            ndp[j]+=sum[j+1];
            if(j>=a[i]) ndp[j]-=sum[j-a[i]];
        }
        dp=ndp;
    }
    cout<<dp[k];
    return 0;
}
```